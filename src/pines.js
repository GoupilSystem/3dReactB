/*
Auto-generated by: https://github.com/pmndrs/gltfjsx
*/

import React, { useState, useRef, useEffect, useMemo } from 'react'
import { useLoader, useFrame, useThree } from 'react-three-fiber'
import { GLTFLoader } from 'three/examples/jsm/loaders/GLTFLoader'
import * as THREE from 'three'

export const Pines = () => {
  const { nodes, materials, animations } = useLoader(GLTFLoader, '/try.gltf')
  const ref = useRef()
  const [mixer] = useState(() => new THREE.AnimationMixer())
  useEffect(() => void mixer.clipAction(animations[0], ref.current).play(), [])
  useFrame(() => {
    mixer.update(0.01)
  })

  function Boxes({ material: Material = 'meshStandardMaterial', amount = 100, spread = 6, color, ...props }) {
    const mesh = useRef()
    const dummy = new THREE.Object3D()
    const rps = () => spread / 2 - Math.random() * spread
    const coords = useMemo(() => new Array(amount).fill().map(() => [rps(), rps(), rps()]), [amount])
    useEffect(state => {
      coords.forEach(([x, y, z], i) => {
        dummy.position.set(x, y, z)
        dummy.updateMatrix()
        mesh.current.setMatrixAt(i, dummy.matrix)
      })
      mesh.current.instanceMatrix.needsUpdate = true
    }, [])
    return (
      <instancedMesh ref={mesh} args={[null, null, amount]} {...props} receiveShadow castShadow>
        <boxBufferGeometry attach="geometry" />
        <Material attach="material" color={color} roughness={1} />
      </instancedMesh>
    )
  }

  function Swarm({ count }) {
    const mesh = useRef();
  
    const dummy = useMemo(() => new THREE.Object3D(), [])
    // Generate some random positions, speed factors and timings
    const particles = useMemo(() => {
      const temp = []
      for (let i = 0; i < count; i++) {
        const t = Math.random() * 100
        const factor = 2 + Math.random() * 2
        const speed = 0.1 + Math.random() / 3
        const xFactor = 1 - Math.random() * 9
        const yFactor = 1 + Math.random() * 5
        const zFactor = -15 + Math.random() * 1.5
        temp.push({ t, factor, speed, xFactor, yFactor, zFactor, mx: 0, my: 0 })
      }
      return temp
    }, [count])
    // The innards of this hook will run every frame
    useFrame(state => {
      // Run through the randomized data to calculate some movement
      particles.forEach((particle, i) => {
        let { t, factor, speed, xFactor, yFactor, zFactor } = particle
        // There is no sense or reason to any of this, just messing around with trigonometric functions
        t = particle.t += speed / 2
        const s = Math.cos(t)
        // Update the dummy object
        dummy.position.set(
          xFactor + (speed / 3) * t + Math.cos(t / factor),
          yFactor - (speed / 3) * t,
          zFactor + (t * factor) / 3
        )
        if (dummy.position.y < 0) {
          particle.t = 0;
        }
        dummy.rotation.set(s * 5, s * 5, s * 5)
        dummy.updateMatrix()
        // And apply the matrix to the instanced item
        mesh.current.setMatrixAt(i, dummy.matrix)
      })
      mesh.current.instanceMatrix.needsUpdate = true
    })
    return (
      <>
        <instancedMesh ref={mesh} args={[null, null, count]}>
          <dodecahedronBufferGeometry attach="geometry" args={[0.05, 0]} />
          <meshBasicMaterial attach="material" color="#ffaaaa" />
        </instancedMesh>
      </>
    )
  }

  return (
    <group ref={ref} dispose={null}>
      <Swarm count={10} />
      <group position={[0.9, -0.2, 0.4]} scale={[0.7,0.7, 0.7]}>
        <primitive object={nodes.Armature_Bone} />
        <primitive object={nodes.Armature_Bone_L} />
        <primitive object={nodes.Armature_Bone_R} />
        <group position={[0, 0.95, 0.07]} scale={[0.12, 0.12, 0.12]}>
          <skinnedMesh
            geometry={nodes.Cube_1.geometry}
            material={materials.Material_Pull}
            skeleton={nodes.Cube_1.skeleton}
          />
          <skinnedMesh
            geometry={nodes.Cube_2.geometry}
            material={materials.Material_Pupil}
            skeleton={nodes.Cube_2.skeleton}
          />
          <skinnedMesh
            geometry={nodes.Cube_3.geometry}
            material={materials.Material_Eye}
            skeleton={nodes.Cube_3.skeleton}
          />
          <skinnedMesh
            geometry={nodes.Cube_4.geometry}
            material={materials.Material_Hair}
            skeleton={nodes.Cube_4.skeleton}
          />
          <skinnedMesh
            geometry={nodes.Cube_5.geometry}
            material={materials.Material_Trousers}
            skeleton={nodes.Cube_5.skeleton}
          />
          <skinnedMesh
            geometry={nodes.Cube_6.geometry}
            material={materials.Material_Shoe}
            skeleton={nodes.Cube_6.skeleton}
          />
          <skinnedMesh
            geometry={nodes.Cube_7.geometry}
            material={materials.Material_Lips}
            skeleton={nodes.Cube_7.skeleton}
          />
          <skinnedMesh
            geometry={nodes.Cube_8.geometry}
            material={materials.Material_Skin}
            skeleton={nodes.Cube_8.skeleton}
          />
        </group>
      </group>
    </group>
  )
}

/*return (
    <group ref={ref} dispose={null}>
      <Boxes amount={2} material="meshBasicMaterial" color="lightpink" />
      <Swarm count={10} />
      <Boxes amount={6} color="#575760" />
      <primitive object={nodes.Armature_Bone} />
        <skinnedMesh material={materials['Material.001']} geometry={nodes.Cube.geometry} skeleton={nodes.Cube.skeleton} />
    </group>
  )

  */
