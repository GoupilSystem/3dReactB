{"ast":null,"code":"import { Box3, Float32BufferAttribute, InstancedBufferGeometry, InstancedInterleavedBuffer, InterleavedBufferAttribute, Sphere, Vector3, WireframeGeometry } from '../../../build/three.module.js';\n\nvar LineSegmentsGeometry = function LineSegmentsGeometry() {\n  InstancedBufferGeometry.call(this);\n  this.type = 'LineSegmentsGeometry';\n  var positions = [-1, 2, 0, 1, 2, 0, -1, 1, 0, 1, 1, 0, -1, 0, 0, 1, 0, 0, -1, -1, 0, 1, -1, 0];\n  var uvs = [-1, 2, 1, 2, -1, 1, 1, 1, -1, -1, 1, -1, -1, -2, 1, -2];\n  var index = [0, 2, 1, 2, 3, 1, 2, 4, 3, 4, 5, 3, 4, 6, 5, 6, 7, 5];\n  this.setIndex(index);\n  this.setAttribute('position', new Float32BufferAttribute(positions, 3));\n  this.setAttribute('uv', new Float32BufferAttribute(uvs, 2));\n};\n\nLineSegmentsGeometry.prototype = Object.assign(Object.create(InstancedBufferGeometry.prototype), {\n  constructor: LineSegmentsGeometry,\n  isLineSegmentsGeometry: true,\n  applyMatrix4: function applyMatrix4(matrix) {\n    var start = this.attributes.instanceStart;\n    var end = this.attributes.instanceEnd;\n\n    if (start !== undefined) {\n      start.applyMatrix4(matrix);\n      end.applyMatrix4(matrix);\n      start.needsUpdate = true;\n    }\n\n    if (this.boundingBox !== null) {\n      this.computeBoundingBox();\n    }\n\n    if (this.boundingSphere !== null) {\n      this.computeBoundingSphere();\n    }\n\n    return this;\n  },\n  setPositions: function setPositions(array) {\n    var lineSegments;\n\n    if (array instanceof Float32Array) {\n      lineSegments = array;\n    } else if (Array.isArray(array)) {\n      lineSegments = new Float32Array(array);\n    }\n\n    var instanceBuffer = new InstancedInterleavedBuffer(lineSegments, 6, 1); // xyz, xyz\n\n    this.setAttribute('instanceStart', new InterleavedBufferAttribute(instanceBuffer, 3, 0)); // xyz\n\n    this.setAttribute('instanceEnd', new InterleavedBufferAttribute(instanceBuffer, 3, 3)); // xyz\n    //\n\n    this.computeBoundingBox();\n    this.computeBoundingSphere();\n    return this;\n  },\n  setColors: function setColors(array) {\n    var colors;\n\n    if (array instanceof Float32Array) {\n      colors = array;\n    } else if (Array.isArray(array)) {\n      colors = new Float32Array(array);\n    }\n\n    var instanceColorBuffer = new InstancedInterleavedBuffer(colors, 6, 1); // rgb, rgb\n\n    this.setAttribute('instanceColorStart', new InterleavedBufferAttribute(instanceColorBuffer, 3, 0)); // rgb\n\n    this.setAttribute('instanceColorEnd', new InterleavedBufferAttribute(instanceColorBuffer, 3, 3)); // rgb\n\n    return this;\n  },\n  fromWireframeGeometry: function fromWireframeGeometry(geometry) {\n    this.setPositions(geometry.attributes.position.array);\n    return this;\n  },\n  fromEdgesGeometry: function fromEdgesGeometry(geometry) {\n    this.setPositions(geometry.attributes.position.array);\n    return this;\n  },\n  fromMesh: function fromMesh(mesh) {\n    this.fromWireframeGeometry(new WireframeGeometry(mesh.geometry)); // set colors, maybe\n\n    return this;\n  },\n  fromLineSegments: function fromLineSegments(lineSegments) {\n    var geometry = lineSegments.geometry;\n\n    if (geometry.isGeometry) {\n      console.error('THREE.LineSegmentsGeometry no longer supports Geometry. Use THREE.BufferGeometry instead.');\n      return;\n    } else if (geometry.isBufferGeometry) {\n      this.setPositions(geometry.attributes.position.array); // assumes non-indexed\n    } // set colors, maybe\n\n\n    return this;\n  },\n  computeBoundingBox: function () {\n    var box = new Box3();\n    return function computeBoundingBox() {\n      if (this.boundingBox === null) {\n        this.boundingBox = new Box3();\n      }\n\n      var start = this.attributes.instanceStart;\n      var end = this.attributes.instanceEnd;\n\n      if (start !== undefined && end !== undefined) {\n        this.boundingBox.setFromBufferAttribute(start);\n        box.setFromBufferAttribute(end);\n        this.boundingBox.union(box);\n      }\n    };\n  }(),\n  computeBoundingSphere: function () {\n    var vector = new Vector3();\n    return function computeBoundingSphere() {\n      if (this.boundingSphere === null) {\n        this.boundingSphere = new Sphere();\n      }\n\n      if (this.boundingBox === null) {\n        this.computeBoundingBox();\n      }\n\n      var start = this.attributes.instanceStart;\n      var end = this.attributes.instanceEnd;\n\n      if (start !== undefined && end !== undefined) {\n        var center = this.boundingSphere.center;\n        this.boundingBox.getCenter(center);\n        var maxRadiusSq = 0;\n\n        for (var i = 0, il = start.count; i < il; i++) {\n          vector.fromBufferAttribute(start, i);\n          maxRadiusSq = Math.max(maxRadiusSq, center.distanceToSquared(vector));\n          vector.fromBufferAttribute(end, i);\n          maxRadiusSq = Math.max(maxRadiusSq, center.distanceToSquared(vector));\n        }\n\n        this.boundingSphere.radius = Math.sqrt(maxRadiusSq);\n\n        if (isNaN(this.boundingSphere.radius)) {\n          console.error('THREE.LineSegmentsGeometry.computeBoundingSphere(): Computed radius is NaN. The instanced position data is likely to have NaN values.', this);\n        }\n      }\n    };\n  }(),\n  toJSON: function toJSON() {// todo\n  },\n  applyMatrix: function applyMatrix(matrix) {\n    console.warn('THREE.LineSegmentsGeometry: applyMatrix() has been renamed to applyMatrix4().');\n    return this.applyMatrix4(matrix);\n  }\n});\nexport { LineSegmentsGeometry };","map":null,"metadata":{},"sourceType":"module"}