{"ast":null,"code":"import _createForOfIteratorHelper from \"C:\\\\Users\\\\scarleti\\\\Desktop\\\\Cyril\\\\React\\\\3dHoverBis\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/createForOfIteratorHelper\";\nimport { BufferAttribute, BufferGeometry, Vector3 } from '../../../build/three.module.js';\nimport { BufferGeometryUtils } from '../utils/BufferGeometryUtils.js';\n\nvar EdgeSplitModifier = function EdgeSplitModifier() {\n  var A = new Vector3();\n  var B = new Vector3();\n  var C = new Vector3();\n  var positions, normals;\n  var indexes;\n  var pointToIndexMap, splitIndexes;\n  let oldNormals;\n\n  function computeNormals() {\n    normals = new Float32Array(indexes.length * 3);\n\n    for (var i = 0; i < indexes.length; i += 3) {\n      var index = indexes[i];\n      A.set(positions[3 * index], positions[3 * index + 1], positions[3 * index + 2]);\n      index = indexes[i + 1];\n      B.set(positions[3 * index], positions[3 * index + 1], positions[3 * index + 2]);\n      index = indexes[i + 2];\n      C.set(positions[3 * index], positions[3 * index + 1], positions[3 * index + 2]);\n      C.sub(B);\n      A.sub(B);\n      var normal = C.cross(A).normalize();\n\n      for (var j = 0; j < 3; j++) {\n        normals[3 * (i + j)] = normal.x;\n        normals[3 * (i + j) + 1] = normal.y;\n        normals[3 * (i + j) + 2] = normal.z;\n      }\n    }\n  }\n\n  function mapPositionsToIndexes() {\n    pointToIndexMap = Array(positions.length / 3);\n\n    for (var i = 0; i < indexes.length; i++) {\n      var index = indexes[i];\n\n      if (pointToIndexMap[index] == null) {\n        pointToIndexMap[index] = [];\n      }\n\n      pointToIndexMap[index].push(i);\n    }\n  }\n\n  function edgeSplitToGroups(indexes, cutOff, firstIndex) {\n    A.set(normals[3 * firstIndex], normals[3 * firstIndex + 1], normals[3 * firstIndex + 2]).normalize();\n    var result = {\n      splitGroup: [],\n      currentGroup: [firstIndex]\n    };\n\n    var _iterator = _createForOfIteratorHelper(indexes),\n        _step;\n\n    try {\n      for (_iterator.s(); !(_step = _iterator.n()).done;) {\n        var j = _step.value;\n\n        if (j !== firstIndex) {\n          B.set(normals[3 * j], normals[3 * j + 1], normals[3 * j + 2]).normalize();\n\n          if (B.dot(A) < cutOff) {\n            result.splitGroup.push(j);\n          } else {\n            result.currentGroup.push(j);\n          }\n        }\n      }\n    } catch (err) {\n      _iterator.e(err);\n    } finally {\n      _iterator.f();\n    }\n\n    return result;\n  }\n\n  function edgeSplit(indexes, cutOff, original = null) {\n    if (indexes.length === 0) return;\n    var groupResults = [];\n\n    var _iterator2 = _createForOfIteratorHelper(indexes),\n        _step2;\n\n    try {\n      for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n        var index = _step2.value;\n        groupResults.push(edgeSplitToGroups(indexes, cutOff, index));\n      }\n    } catch (err) {\n      _iterator2.e(err);\n    } finally {\n      _iterator2.f();\n    }\n\n    var result = groupResults[0];\n\n    for (var _i = 0, _groupResults = groupResults; _i < _groupResults.length; _i++) {\n      var groupResult = _groupResults[_i];\n\n      if (groupResult.currentGroup.length > result.currentGroup.length) {\n        result = groupResult;\n      }\n    }\n\n    if (original != null) {\n      splitIndexes.push({\n        original: original,\n        indexes: result.currentGroup\n      });\n    }\n\n    if (result.splitGroup.length) {\n      edgeSplit(result.splitGroup, cutOff, original || result.currentGroup[0]);\n    }\n  }\n\n  this.modify = function (geometry, cutOffAngle, tryKeepNormals = true) {\n    if (geometry.isGeometry === true) {\n      console.error('THREE.EdgeSplitModifier no longer supports THREE.Geometry. Use BufferGeometry instead.');\n      return;\n    }\n\n    let hadNormals = false;\n    oldNormals = null;\n\n    if (geometry.attributes.normal) {\n      hadNormals = true;\n      geometry = geometry.clone();\n\n      if (tryKeepNormals === true && geometry.index !== null) {\n        oldNormals = geometry.attributes.normal.array;\n      }\n\n      geometry.deleteAttribute('normal');\n    }\n\n    if (geometry.index == null) {\n      if (BufferGeometryUtils === undefined) {\n        throw 'THREE.EdgeSplitModifier relies on BufferGeometryUtils';\n      }\n\n      geometry = BufferGeometryUtils.mergeVertices(geometry);\n    }\n\n    indexes = geometry.index.array;\n    positions = geometry.getAttribute('position').array;\n    computeNormals();\n    mapPositionsToIndexes();\n    splitIndexes = [];\n\n    var _iterator3 = _createForOfIteratorHelper(pointToIndexMap),\n        _step3;\n\n    try {\n      for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n        var vertexIndexes = _step3.value;\n        edgeSplit(vertexIndexes, Math.cos(cutOffAngle) - 0.001);\n      }\n    } catch (err) {\n      _iterator3.e(err);\n    } finally {\n      _iterator3.f();\n    }\n\n    const newAttributes = {};\n\n    for (var _i2 = 0, _Object$keys = Object.keys(geometry.attributes); _i2 < _Object$keys.length; _i2++) {\n      const name = _Object$keys[_i2];\n      const oldAttribute = geometry.attributes[name];\n      const newArray = new oldAttribute.array.constructor((indexes.length + splitIndexes.length) * oldAttribute.itemSize);\n      newArray.set(oldAttribute.array);\n      newAttributes[name] = new BufferAttribute(newArray, oldAttribute.itemSize, oldAttribute.normalized);\n    }\n\n    var newIndexes = new Uint32Array(indexes.length);\n    newIndexes.set(indexes);\n\n    for (var i = 0; i < splitIndexes.length; i++) {\n      var split = splitIndexes[i];\n      var index = indexes[split.original];\n\n      for (var _i3 = 0, _Object$values = Object.values(newAttributes); _i3 < _Object$values.length; _i3++) {\n        const attribute = _Object$values[_i3];\n\n        for (let j = 0; j < attribute.itemSize; j++) {\n          attribute.array[(indexes.length + i) * attribute.itemSize + j] = attribute.array[index * attribute.itemSize + j];\n        }\n      }\n\n      var _iterator4 = _createForOfIteratorHelper(split.indexes),\n          _step4;\n\n      try {\n        for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {\n          var j = _step4.value;\n          newIndexes[j] = indexes.length + i;\n        }\n      } catch (err) {\n        _iterator4.e(err);\n      } finally {\n        _iterator4.f();\n      }\n    }\n\n    geometry = new BufferGeometry();\n    geometry.setIndex(new BufferAttribute(newIndexes, 1));\n\n    for (var _i4 = 0, _Object$keys2 = Object.keys(newAttributes); _i4 < _Object$keys2.length; _i4++) {\n      const name = _Object$keys2[_i4];\n      geometry.setAttribute(name, newAttributes[name]);\n    }\n\n    if (hadNormals) {\n      geometry.computeVertexNormals();\n\n      if (oldNormals !== null) {\n        const changedNormals = new Array(oldNormals.length / 3).fill(false);\n\n        var _iterator5 = _createForOfIteratorHelper(splitIndexes),\n            _step5;\n\n        try {\n          for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {\n            const splitData = _step5.value;\n            changedNormals[splitData.original] = true;\n          }\n        } catch (err) {\n          _iterator5.e(err);\n        } finally {\n          _iterator5.f();\n        }\n\n        for (let i = 0; i < changedNormals.length; i++) {\n          if (changedNormals[i] === false) {\n            for (let j = 0; j < 3; j++) geometry.attributes.normal.array[3 * i + j] = oldNormals[3 * i + j];\n          }\n        }\n      }\n    }\n\n    return geometry;\n  };\n};\n\nexport { EdgeSplitModifier };","map":null,"metadata":{},"sourceType":"module"}